#!/usr/bin/env python3
"""
Shellockolm Malware Analyzer
Deep code analysis, malicious pattern detection, and remediation engine

Features:
- Malicious code pattern database for known CVEs
- Deep JavaScript/TypeScript code analysis
- Code extraction and explanation
- Quarantine and removal of malicious packages
- Surgical code cleanup
"""

import os
import re
import json
import shutil
import hashlib
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Optional, Tuple, Any
from dataclasses import dataclass, field
from enum import Enum

# ─────────────────────────────────────────────────────────────────
# ENUMS AND DATA CLASSES
# ─────────────────────────────────────────────────────────────────

class ThreatLevel(Enum):
    """Threat severity levels"""
    CRITICAL = "CRITICAL"  # Active exploitation, RCE, data theft
    HIGH = "HIGH"          # Significant security risk
    MEDIUM = "MEDIUM"      # Potential security issue
    LOW = "LOW"            # Minor concern
    INFO = "INFO"          # Informational finding


class MalwareType(Enum):
    """Types of malicious behavior"""
    RCE = "Remote Code Execution"
    DATA_EXFIL = "Data Exfiltration"
    BACKDOOR = "Backdoor/Reverse Shell"
    CRYPTO_MINER = "Cryptocurrency Miner"
    CREDENTIAL_THEFT = "Credential Theft"
    SUPPLY_CHAIN = "Supply Chain Attack"
    TYPOSQUAT = "Typosquatting Package"
    INSTALL_HOOK = "Malicious Install Hook"
    OBFUSCATED = "Obfuscated Malicious Code"
    DEPENDENCY_CONFUSION = "Dependency Confusion"
    PROTOTYPE_POLLUTION = "Prototype Pollution"
    PATH_TRAVERSAL = "Path Traversal"
    SSRF = "Server-Side Request Forgery"
    COMMAND_INJECTION = "Command Injection"
    SQL_INJECTION = "SQL Injection"
    XSS = "Cross-Site Scripting"
    DESERIALIZATION = "Insecure Deserialization"
    KEYLOGGER = "Keylogger/Input Capture"
    CLIPBOARD_HIJACK = "Clipboard Hijacking"
    DNS_REBINDING = "DNS Rebinding"
    SECRETS_EXPOSURE = "Secrets/API Key Exposure"
    UNSAFE_REDIRECT = "Unsafe Redirect"
    FILE_INCLUSION = "File Inclusion"
    REGEX_DOS = "Regular Expression DoS"
    TIMING_ATTACK = "Timing Attack"


@dataclass
class MaliciousPattern:
    """A pattern that indicates malicious code"""
    id: str
    name: str
    description: str
    pattern: str  # Regex pattern
    pattern_type: str  # "regex", "ast", "string"
    threat_level: ThreatLevel
    malware_type: MalwareType
    cve_ids: List[str] = field(default_factory=list)
    explanation: str = ""
    remediation: str = ""
    false_positive_hints: List[str] = field(default_factory=list)


@dataclass
class MalwareMatch:
    """A match found in code"""
    pattern_id: str = ""
    pattern_name: str = ""
    threat_level: ThreatLevel = ThreatLevel.MEDIUM
    malware_type: MalwareType = MalwareType.RCE
    cve_ids: List[str] = field(default_factory=list)
    explanation: str = ""
    remediation: str = ""
    file_path: str = ""
    line_number: int = 0
    line_content: str = ""
    context_before: List[str] = field(default_factory=list)
    context_after: List[str] = field(default_factory=list)
    matched_text: str = ""
    package_name: Optional[str] = None
    package_version: Optional[str] = None

    @classmethod
    def from_pattern(cls, pattern: 'MaliciousPattern', **kwargs) -> 'MalwareMatch':
        """Create MalwareMatch from a MaliciousPattern"""
        return cls(
            pattern_id=pattern.id,
            pattern_name=pattern.name,
            threat_level=pattern.threat_level,
            malware_type=pattern.malware_type,
            cve_ids=pattern.cve_ids,
            explanation=pattern.explanation,
            remediation=pattern.remediation,
            **kwargs
        )


@dataclass
class AnalysisReport:
    """Complete analysis report for a project"""
    scan_id: str = ""
    scan_time: datetime = field(default_factory=datetime.now)
    target_path: str = ""
    files_scanned: int = 0
    total_files_scanned: int = 0
    total_packages_scanned: int = 0
    packages_scanned: int = 0
    matches: List[MalwareMatch] = field(default_factory=list)
    quarantined_files: List[str] = field(default_factory=list)
    removed_packages: List[str] = field(default_factory=list)
    cleaned_files: List[str] = field(default_factory=list)
    duration: float = 0.0


# ─────────────────────────────────────────────────────────────────
# MALICIOUS CODE PATTERNS DATABASE
# ─────────────────────────────────────────────────────────────────

MALICIOUS_PATTERNS: List[MaliciousPattern] = [
    # ═══════════════════════════════════════════════════════════
    # CVE-2025-29927: Next.js Middleware Bypass
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="NEXTJS-MIDDLEWARE-BYPASS-001",
        name="Next.js Middleware Bypass Header",
        description="Detects x-middleware-subrequest header injection used to bypass auth",
        pattern=r"x-middleware-subrequest|x-middleware-prefetch.*true",
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.BACKDOOR,
        cve_ids=["CVE-2025-29927"],
        explanation="This header allows bypassing Next.js middleware authentication checks. Attackers can access protected routes without authentication.",
        remediation="Upgrade Next.js to 14.2.26+, 15.2.4+, or 13.5.10+. Add server-side auth checks.",
    ),

    # ═══════════════════════════════════════════════════════════
    # CVE-2025-55182: React Server Components RCE
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="REACT-RSC-RCE-001",
        name="React RSC Deserialization Exploit",
        description="Malicious React Server Component payload for RCE",
        pattern=r"__react_flight_deserialize|createFromFetch.*eval|Function\s*\(['\"]return",
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.RCE,
        cve_ids=["CVE-2025-55182"],
        explanation="Exploits React Flight protocol deserialization to achieve remote code execution on the server.",
        remediation="Upgrade react and react-server-dom-webpack to 19.1.0+. Validate all RSC payloads.",
    ),
    MaliciousPattern(
        id="REACT-RSC-RCE-002",
        name="React Flight Payload Injection",
        description="Detects crafted React Flight payloads used for RCE",
        pattern=r'\$F.*\$L.*function|importScripts|__webpack_require__.*eval',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.RCE,
        cve_ids=["CVE-2025-55182", "CVE-2025-66478"],
        explanation="Crafted Flight payloads that exploit deserialization to execute arbitrary code.",
        remediation="Update to patched versions. Implement payload validation.",
    ),

    # ═══════════════════════════════════════════════════════════
    # CVE-2026-21858: n8n Ni8mare RCE
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="N8N-NIMARE-001",
        name="n8n Content-Type Confusion Exploit",
        description="Exploits n8n Form Webhook Content-Type handling for RCE",
        pattern=r'application/x-www-form-urlencoded.*\$\{|child_process|require\s*\(\s*[\'"]child_process',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.RCE,
        cve_ids=["CVE-2026-21858"],
        explanation="Exploits Content-Type confusion in n8n Form Webhooks to achieve unauthenticated RCE.",
        remediation="Upgrade n8n to 1.89.0+. Restrict webhook access.",
    ),

    # ═══════════════════════════════════════════════════════════
    # SUPPLY CHAIN ATTACKS - Shai-Hulud Worm
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="SHAI-HULUD-001",
        name="Shai-Hulud Worm npm Token Theft",
        description="Detects Shai-Hulud worm stealing npm tokens from CI/CD",
        pattern=r'NPM_TOKEN|npm_token|\.npmrc|//registry\.npmjs\.org/:_authToken',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.SUPPLY_CHAIN,
        cve_ids=["CVE-2025-WORM-001"],
        explanation="The Shai-Hulud worm spreads through npm packages by stealing tokens from CI/CD environments and using them to publish malicious versions.",
        remediation="Rotate all npm tokens immediately. Use npm provenance. Enable 2FA on npm.",
    ),
    MaliciousPattern(
        id="SHAI-HULUD-002",
        name="Shai-Hulud Self-Propagation Code",
        description="Detects worm propagation mechanism",
        pattern=r'npm\s+publish|npm\s+version\s+patch|git\s+push.*--force|exec\s*\(.*npm\s+publish',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.SUPPLY_CHAIN,
        cve_ids=["CVE-2025-WORM-001"],
        explanation="Self-propagation code that publishes malicious versions to npm.",
        remediation="Remove infected packages. Audit all dependencies. Revoke tokens.",
    ),

    # ═══════════════════════════════════════════════════════════
    # MALICIOUS INSTALL HOOKS
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="INSTALL-HOOK-001",
        name="Malicious preinstall/postinstall Script",
        description="Detects suspicious code in npm install hooks",
        pattern=r'"(pre|post)install"\s*:\s*"[^"]*(?:curl|wget|nc|bash|sh|eval|exec|child_process)',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.INSTALL_HOOK,
        explanation="Install hooks that download and execute external code or open reverse shells.",
        remediation="Remove the package. Run with --ignore-scripts. Audit package.json scripts.",
    ),
    MaliciousPattern(
        id="INSTALL-HOOK-002",
        name="Base64 Encoded Install Script",
        description="Detects base64 encoded payloads in install scripts",
        pattern=r'"(pre|post)install"\s*:\s*"[^"]*(?:base64|atob|Buffer\.from)',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.OBFUSCATED,
        explanation="Install scripts using base64 encoding to hide malicious payloads.",
        remediation="Decode and analyze the payload. Remove if malicious.",
    ),

    # ═══════════════════════════════════════════════════════════
    # DATA EXFILTRATION PATTERNS
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="EXFIL-001",
        name="Environment Variable Exfiltration",
        description="Detects code stealing environment variables",
        pattern=r'process\.env.*(?:fetch|axios|http|request|XMLHttpRequest)|(?:fetch|axios).*process\.env',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.DATA_EXFIL,
        explanation="Code that steals environment variables (including secrets, API keys) and sends them to external servers.",
        remediation="Remove the package immediately. Rotate all exposed secrets.",
    ),
    MaliciousPattern(
        id="EXFIL-002",
        name="Hostname/IP Exfiltration",
        description="Detects code collecting system info for exfiltration",
        pattern=r'os\.hostname\(\)|os\.networkInterfaces\(\)|os\.userInfo\(\).*(?:fetch|http|request)',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.DATA_EXFIL,
        explanation="Collects system information for reconnaissance or tracking.",
        remediation="Remove package. Check for data breach indicators.",
    ),
    MaliciousPattern(
        id="EXFIL-003",
        name="SSH Key/Credential File Access",
        description="Detects access to SSH keys and credential files",
        pattern=r'\.ssh/|id_rsa|id_ed25519|\.aws/credentials|\.netrc|\.npmrc',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.CREDENTIAL_THEFT,
        explanation="Attempts to read SSH keys, AWS credentials, or npm tokens.",
        remediation="Remove immediately. Rotate all keys and tokens.",
    ),

    # ═══════════════════════════════════════════════════════════
    # REVERSE SHELLS AND BACKDOORS
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="REVSHELL-001",
        name="Reverse Shell via Child Process",
        description="Detects reverse shell establishment",
        pattern=r'child_process.*(?:\/bin\/(?:ba)?sh|cmd\.exe).*(?:socket|net\.connect|tcp)',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.BACKDOOR,
        explanation="Creates a reverse shell connecting back to attacker's server.",
        remediation="Remove immediately. Check for active connections. Incident response.",
    ),
    MaliciousPattern(
        id="REVSHELL-002",
        name="WebSocket Backdoor",
        description="Detects WebSocket-based command execution",
        pattern=r'WebSocket.*on\s*\(\s*[\'"]message[\'"].*(?:eval|exec|spawn|fork)',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.BACKDOOR,
        explanation="WebSocket-based backdoor receiving and executing commands.",
        remediation="Remove package. Audit all WebSocket connections.",
    ),

    # ═══════════════════════════════════════════════════════════
    # OBFUSCATION PATTERNS
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="OBFUSCATE-001",
        name="Hex/Unicode Obfuscated Code",
        description="Detects heavily obfuscated JavaScript",
        pattern=r'\\x[0-9a-fA-F]{2}\\x[0-9a-fA-F]{2}\\x[0-9a-fA-F]{2}|\\u[0-9a-fA-F]{4}\\u[0-9a-fA-F]{4}',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.OBFUSCATED,
        explanation="Heavily obfuscated code often hides malicious payloads.",
        remediation="Deobfuscate and analyze. Remove if malicious.",
    ),
    MaliciousPattern(
        id="OBFUSCATE-002",
        name="eval() with Encoded String",
        description="Detects eval with encoded/obfuscated input",
        pattern=r'eval\s*\(\s*(?:atob|Buffer\.from|decodeURIComponent|unescape)\s*\(',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.OBFUSCATED,
        explanation="eval() with encoded input is a common malware technique.",
        remediation="Decode payload. Remove package if malicious.",
    ),
    MaliciousPattern(
        id="OBFUSCATE-003",
        name="Function Constructor Execution",
        description="Detects Function constructor for code execution",
        pattern=r'new\s+Function\s*\([^)]*\)\s*\(\)|Function\s*\([\'"][^\'"]*[\'"].*\)\s*\(',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.OBFUSCATED,
        explanation="Function constructor used to execute dynamically built code.",
        remediation="Analyze what code is being constructed. Remove if malicious.",
    ),

    # ═══════════════════════════════════════════════════════════
    # CRYPTO MINERS
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="MINER-001",
        name="Cryptocurrency Mining Code",
        description="Detects crypto mining scripts",
        pattern=r'coinhive|cryptonight|stratum\+tcp|xmrig|minero|hashrate|CoinImp',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.CRYPTO_MINER,
        explanation="Cryptocurrency mining code using your CPU resources.",
        remediation="Remove the package. Check CPU usage history.",
    ),

    # ═══════════════════════════════════════════════════════════
    # CVE-SPECIFIC: mysql2 RCE
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="MYSQL2-RCE-001",
        name="mysql2 Prototype Pollution RCE",
        description="Detects exploitation of mysql2 prototype pollution",
        pattern=r'__proto__|constructor\.prototype|Object\.prototype.*mysql2',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.RCE,
        cve_ids=["CVE-2024-21508"],
        explanation="Prototype pollution in mysql2 can lead to remote code execution.",
        remediation="Upgrade mysql2 to 3.11.5+. Sanitize all user inputs.",
    ),

    # ═══════════════════════════════════════════════════════════
    # CVE-SPECIFIC: jsonpath-plus RCE
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="JSONPATH-RCE-001",
        name="jsonpath-plus Code Injection",
        description="Detects jsonpath-plus RCE via expression injection",
        pattern=r'JSONPath.*\$\[.*constructor|jsonpath.*eval|jp\.query.*\(\s*[\'"].*constructor',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.RCE,
        cve_ids=["CVE-2024-21534", "CVE-2025-1302"],
        explanation="jsonpath-plus allows code injection through malicious JSONPath expressions.",
        remediation="Upgrade to jsonpath-plus 10.3.0+. Never use untrusted JSONPath expressions.",
    ),

    # ═══════════════════════════════════════════════════════════
    # TYPOSQUATTING DETECTION
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="TYPOSQUAT-001",
        name="Known Typosquatting Package Names",
        description="Detects known typosquatting package names",
        pattern=r'"(lodashs?|reacts?-dom|angularjs?-core|expresss|axois|momment|jquerry|babael|colurs|crosss-env|event-streem)"',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.TYPOSQUAT,
        explanation="Package name is a known typosquat of a popular package.",
        remediation="Remove immediately. Install the correct package.",
    ),

    # ═══════════════════════════════════════════════════════════
    # SUSPICIOUS NETWORK ACTIVITY
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="NETWORK-001",
        name="Suspicious External Domain Contact",
        description="Detects connections to suspicious domains",
        pattern=r'(?:fetch|axios|http|request)\s*\([\'"]https?://(?:[a-z0-9]+\.)?(?:pastebin|transfer\.sh|webhook\.site|requestbin|ngrok|burpcollaborator|interact\.sh)',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.DATA_EXFIL,
        explanation="Package contacts suspicious exfiltration or C2 domains.",
        remediation="Remove package. Investigate what data was sent.",
    ),
    MaliciousPattern(
        id="NETWORK-002",
        name="Dynamic URL Construction",
        description="Detects dynamic URL building (often for C2)",
        pattern=r'[\'"][a-z]+:\/\/[\'"\s]*\+.*(?:fetch|axios|request|http\.get)',
        pattern_type="regex",
        threat_level=ThreatLevel.MEDIUM,
        malware_type=MalwareType.DATA_EXFIL,
        explanation="Dynamically constructed URLs can be used for C2 communication.",
        remediation="Analyze what URLs are being constructed.",
        false_positive_hints=["API endpoint construction", "Config-based URLs"],
    ),

    # ═══════════════════════════════════════════════════════════
    # PROTOTYPE POLLUTION ATTACKS
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="PROTO-001",
        name="Direct __proto__ Assignment",
        description="Detects direct prototype pollution via __proto__",
        pattern=r'__proto__\s*\[|__proto__\s*\.\s*[a-zA-Z]|\[[\'""]__proto__[\'""]\]',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.PROTOTYPE_POLLUTION,
        explanation="Direct __proto__ assignment can pollute Object.prototype affecting all objects.",
        remediation="Use Object.create(null) for dictionaries. Validate user input keys.",
    ),
    MaliciousPattern(
        id="PROTO-002",
        name="Constructor Prototype Access",
        description="Detects prototype pollution via constructor.prototype",
        pattern=r'constructor\s*\[\s*[\'"]prototype[\'"]\s*\]|constructor\.prototype\s*\[',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.PROTOTYPE_POLLUTION,
        explanation="Accessing constructor.prototype can lead to prototype pollution.",
        remediation="Block 'constructor' and 'prototype' keys from user input.",
    ),
    MaliciousPattern(
        id="PROTO-003",
        name="Object.assign Pollution",
        description="Detects prototype pollution via Object.assign with user input",
        pattern=r'Object\.assign\s*\(\s*(?:Object\.prototype|{}|target)',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.PROTOTYPE_POLLUTION,
        explanation="Object.assign can be used to pollute prototypes with malicious properties.",
        remediation="Sanitize object keys before using Object.assign.",
    ),
    MaliciousPattern(
        id="PROTO-004",
        name="Lodash/jQuery Deep Merge Pollution",
        description="Detects vulnerable deep merge functions",
        pattern=r'(?:_\.merge|_\.defaultsDeep|\$\.extend\s*\(\s*true|deepmerge)\s*\(',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.PROTOTYPE_POLLUTION,
        cve_ids=["CVE-2019-10744", "CVE-2020-28500"],
        explanation="Deep merge functions can be exploited for prototype pollution.",
        remediation="Update lodash to 4.17.21+. Sanitize merge sources.",
    ),

    # ═══════════════════════════════════════════════════════════
    # PATH TRAVERSAL ATTACKS
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="PATH-001",
        name="Path Traversal Sequence",
        description="Detects path traversal patterns",
        pattern=r'\.\./\.\./|\.\.\\\\\.\.\\\\|%2e%2e%2f|%252e%252e%252f',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.PATH_TRAVERSAL,
        explanation="Path traversal sequences attempting to access files outside intended directory.",
        remediation="Use path.normalize() and validate paths. Use allowlists.",
    ),
    MaliciousPattern(
        id="PATH-002",
        name="Unsanitized Path Concatenation",
        description="Detects unsafe path construction from user input",
        pattern=r'(?:path\.join|path\.resolve|fs\.(?:read|write|unlink|rmdir))\s*\([^)]*(?:req\.(?:params|query|body)|user[Ii]nput)',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.PATH_TRAVERSAL,
        explanation="User input directly used in file path operations.",
        remediation="Validate and sanitize paths. Use path.basename() for filenames.",
    ),
    MaliciousPattern(
        id="PATH-003",
        name="Null Byte Injection",
        description="Detects null byte injection in paths",
        pattern=r'%00|\\x00|\\u0000',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.PATH_TRAVERSAL,
        explanation="Null byte injection can truncate file paths and bypass extension checks.",
        remediation="Filter null bytes from all user input.",
    ),

    # ═══════════════════════════════════════════════════════════
    # SERVER-SIDE REQUEST FORGERY (SSRF)
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="SSRF-001",
        name="SSRF to Internal Networks",
        description="Detects requests to internal/private IP ranges",
        pattern=r'(?:fetch|axios|request|http\.get)\s*\([^)]*(?:127\.|10\.|172\.(?:1[6-9]|2[0-9]|3[01])\.|192\.168\.|localhost|0\.0\.0\.0)',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.SSRF,
        explanation="Requests to internal IP addresses can be used for SSRF attacks.",
        remediation="Validate URLs against allowlist. Block internal IP ranges.",
    ),
    MaliciousPattern(
        id="SSRF-002",
        name="SSRF via URL Parameter",
        description="Detects user-controlled URL in HTTP requests",
        pattern=r'(?:fetch|axios|request)\s*\(\s*(?:req\.(?:params|query|body)|url|target|endpoint)',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.SSRF,
        explanation="User-controlled URLs in HTTP requests can lead to SSRF.",
        remediation="Validate URLs. Implement URL allowlist. Use DNS resolution checks.",
    ),
    MaliciousPattern(
        id="SSRF-003",
        name="Cloud Metadata SSRF",
        description="Detects SSRF targeting cloud metadata endpoints",
        pattern=r'169\.254\.169\.254|metadata\.google|169\.254\.170\.2',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.SSRF,
        explanation="Accessing cloud metadata endpoints can expose credentials and secrets.",
        remediation="Block metadata IP addresses. Use IMDSv2 on AWS.",
    ),

    # ═══════════════════════════════════════════════════════════
    # COMMAND INJECTION
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="CMDI-001",
        name="Shell Command Injection",
        description="Detects shell command injection vulnerabilities",
        pattern=r'(?:exec|execSync|spawn|spawnSync)\s*\([^)]*(?:\+|`|\$\{|req\.|user)',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.COMMAND_INJECTION,
        explanation="User input in shell commands can lead to command injection.",
        remediation="Use parameterized commands. Avoid shell=true. Use execFile instead of exec.",
    ),
    MaliciousPattern(
        id="CMDI-002",
        name="Backtick Command Substitution",
        description="Detects command substitution in strings",
        pattern=r'`[^`]*\$\([^)]+\)[^`]*`|`[^`]*\${[^}]+}[^`]*`',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.COMMAND_INJECTION,
        explanation="Template literals with command substitution can execute commands.",
        remediation="Sanitize all user input. Use child_process.execFile().",
    ),
    MaliciousPattern(
        id="CMDI-003",
        name="Shell Metacharacter Injection",
        description="Detects shell metacharacters in commands",
        pattern=r'(?:exec|spawn)\s*\([^)]*(?:;|\||&&|\$\(|`)',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.COMMAND_INJECTION,
        explanation="Shell metacharacters can chain additional commands.",
        remediation="Escape or reject shell metacharacters. Use arrays for arguments.",
    ),

    # ═══════════════════════════════════════════════════════════
    # SQL INJECTION IN JAVASCRIPT
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="SQLI-001",
        name="SQL String Concatenation",
        description="Detects SQL queries built with string concatenation",
        pattern=r'(?:SELECT|INSERT|UPDATE|DELETE|DROP|UNION)[^;]*(?:\+|`|\$\{)[^;]*(?:req\.|user|input|param)',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.SQL_INJECTION,
        explanation="SQL queries built with string concatenation are vulnerable to injection.",
        remediation="Use parameterized queries or prepared statements.",
    ),
    MaliciousPattern(
        id="SQLI-002",
        name="Raw SQL Query Execution",
        description="Detects raw SQL execution with user input",
        pattern=r'\.(?:query|raw|execute)\s*\(\s*[\'"`][^\'"`]*(?:\+|\$\{)',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.SQL_INJECTION,
        explanation="Raw SQL queries with user input are vulnerable to injection.",
        remediation="Use ORM methods or parameterized queries.",
    ),

    # ═══════════════════════════════════════════════════════════
    # XSS PATTERNS
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="XSS-001",
        name="innerHTML Assignment",
        description="Detects dangerous innerHTML with user input",
        pattern=r'\.innerHTML\s*=\s*(?![\'""])[^;]*(?:req\.|user|input|\+)',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.XSS,
        explanation="Setting innerHTML with user input can lead to XSS.",
        remediation="Use textContent or sanitize HTML with DOMPurify.",
    ),
    MaliciousPattern(
        id="XSS-002",
        name="Document.write Injection",
        description="Detects document.write with user input",
        pattern=r'document\.write\s*\([^)]*(?:\+|\$\{|req\.|user)',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.XSS,
        explanation="document.write with user input enables XSS attacks.",
        remediation="Use DOM manipulation methods instead of document.write.",
    ),
    MaliciousPattern(
        id="XSS-003",
        name="React dangerouslySetInnerHTML",
        description="Detects dangerous React HTML injection",
        pattern=r'dangerouslySetInnerHTML\s*=\s*\{\s*\{\s*__html\s*:\s*(?![\'""])',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.XSS,
        cve_ids=["CVE-2025-55182"],
        explanation="dangerouslySetInnerHTML with unsanitized input causes XSS.",
        remediation="Sanitize HTML with DOMPurify before using dangerouslySetInnerHTML.",
    ),

    # ═══════════════════════════════════════════════════════════
    # INSECURE DESERIALIZATION
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="DESER-001",
        name="Unsafe YAML Parsing",
        description="Detects unsafe YAML parsing with load()",
        pattern=r'yaml\.load\s*\(|js-yaml.*load\s*\(',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.DESERIALIZATION,
        cve_ids=["CVE-2023-26159"],
        explanation="YAML load() can execute arbitrary code via custom tags.",
        remediation="Use yaml.safeLoad() or js-yaml with safe schema.",
    ),
    MaliciousPattern(
        id="DESER-002",
        name="Node-serialize Deserialization",
        description="Detects dangerous node-serialize usage",
        pattern=r'node-serialize|serialize\.unserialize\s*\(',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.DESERIALIZATION,
        cve_ids=["CVE-2017-5941"],
        explanation="node-serialize can execute arbitrary code during deserialization.",
        remediation="Remove node-serialize. Use JSON.parse() for data serialization.",
    ),
    MaliciousPattern(
        id="DESER-003",
        name="Arbitrary Object Instantiation",
        description="Detects dynamic class instantiation from user input",
        pattern=r'new\s+(?:window|global|globalThis)\s*\[[^\]]+\]|new\s+[a-zA-Z]+\[',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.DESERIALIZATION,
        explanation="Dynamic class instantiation can be exploited for code execution.",
        remediation="Use allowlist for class names. Don't instantiate from user input.",
    ),

    # ═══════════════════════════════════════════════════════════
    # KEYLOGGERS AND INPUT CAPTURE
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="KEYLOG-001",
        name="Keyboard Event Logger",
        description="Detects keylogger patterns capturing keystrokes",
        pattern=r'(?:addEventListener|on(?:keydown|keypress|keyup))\s*[=(][^)]*(?:fetch|XMLHttpRequest|navigator\.sendBeacon)',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.KEYLOGGER,
        explanation="Code capturing keystrokes and sending them to external server.",
        remediation="Remove the keylogger code. Audit all event listeners.",
    ),
    MaliciousPattern(
        id="KEYLOG-002",
        name="Form Data Interception",
        description="Detects form submission interception",
        pattern=r'(?:addEventListener|onsubmit)\s*[=(][^)]*(?:FormData|serialize).*(?:fetch|XMLHttpRequest)',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.KEYLOGGER,
        explanation="Form data interception can steal credentials and sensitive data.",
        remediation="Audit form handling code. Verify submission endpoints.",
    ),

    # ═══════════════════════════════════════════════════════════
    # CLIPBOARD HIJACKING
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="CLIP-001",
        name="Clipboard Content Theft",
        description="Detects clipboard reading and exfiltration",
        pattern=r'navigator\.clipboard\.readText|clipboardData\.getData.*(?:fetch|XMLHttpRequest|sendBeacon)',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.CLIPBOARD_HIJACK,
        explanation="Stealing clipboard contents can expose passwords and sensitive data.",
        remediation="Remove clipboard reading code unless explicitly needed.",
    ),
    MaliciousPattern(
        id="CLIP-002",
        name="Clipboard Content Replacement",
        description="Detects clipboard hijacking (crypto address swap)",
        pattern=r'navigator\.clipboard\.writeText|execCommand\s*\(\s*[\'"]copy[\'"]|clipboardData\.setData',
        pattern_type="regex",
        threat_level=ThreatLevel.MEDIUM,
        malware_type=MalwareType.CLIPBOARD_HIJACK,
        explanation="Clipboard replacement can swap crypto addresses to steal funds.",
        remediation="Audit clipboard write operations. Verify legitimate use case.",
        false_positive_hints=["Copy to clipboard buttons", "Text editor features"],
    ),

    # ═══════════════════════════════════════════════════════════
    # SECRETS AND API KEY EXPOSURE
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="SECRET-001",
        name="Hardcoded AWS Credentials",
        description="Detects hardcoded AWS access keys",
        pattern=r'AKIA[0-9A-Z]{16}|(?:aws_secret_access_key|aws_access_key_id)\s*[=:]\s*[\'"][A-Za-z0-9+/]{40}[\'"]',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.SECRETS_EXPOSURE,
        explanation="Hardcoded AWS credentials can be exploited for unauthorized access.",
        remediation="Remove credentials. Use environment variables or AWS IAM roles.",
    ),
    MaliciousPattern(
        id="SECRET-002",
        name="Hardcoded Private Keys",
        description="Detects private keys in code",
        pattern=r'-----BEGIN (?:RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----|-----BEGIN PGP PRIVATE KEY BLOCK-----',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.SECRETS_EXPOSURE,
        explanation="Private keys in source code can be exploited for impersonation.",
        remediation="Remove keys from code. Use secure key management.",
    ),
    MaliciousPattern(
        id="SECRET-003",
        name="Hardcoded API Keys",
        description="Detects common API key patterns",
        pattern=r'(?:api[_-]?key|apikey|api[_-]?secret)\s*[=:]\s*[\'"][a-zA-Z0-9_-]{20,}[\'"]',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.SECRETS_EXPOSURE,
        explanation="Hardcoded API keys can be extracted and abused.",
        remediation="Use environment variables for API keys.",
    ),
    MaliciousPattern(
        id="SECRET-004",
        name="GitHub/GitLab Tokens",
        description="Detects GitHub and GitLab access tokens",
        pattern=r'gh[pousr]_[A-Za-z0-9_]{36}|glpat-[A-Za-z0-9_-]{20,}',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.SECRETS_EXPOSURE,
        explanation="Git platform tokens can access repositories and deploy malicious code.",
        remediation="Revoke and rotate tokens. Use environment variables.",
    ),
    MaliciousPattern(
        id="SECRET-005",
        name="Slack/Discord Webhooks",
        description="Detects webhook URLs that can be abused",
        pattern=r'hooks\.slack\.com/services/[A-Z0-9]+/[A-Z0-9]+/[a-zA-Z0-9]+|discord(?:app)?\.com/api/webhooks/[0-9]+/[A-Za-z0-9_-]+',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.SECRETS_EXPOSURE,
        explanation="Exposed webhooks can be used for spam or phishing.",
        remediation="Rotate webhook URLs. Use environment variables.",
    ),
    MaliciousPattern(
        id="SECRET-006",
        name="JWT Secret Exposure",
        description="Detects hardcoded JWT secrets",
        pattern=r'(?:jwt[_-]?secret|token[_-]?secret)\s*[=:]\s*[\'"][^\'"]{10,}[\'"]',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.SECRETS_EXPOSURE,
        explanation="JWT secrets can forge authentication tokens.",
        remediation="Use strong, unique secrets from environment variables.",
    ),

    # ═══════════════════════════════════════════════════════════
    # UNSAFE REDIRECTS
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="REDIR-001",
        name="Open Redirect Vulnerability",
        description="Detects unsafe redirects from user input",
        pattern=r'(?:res\.redirect|location\.href|window\.location)\s*[=(]\s*(?:req\.|params|query|url|target)',
        pattern_type="regex",
        threat_level=ThreatLevel.MEDIUM,
        malware_type=MalwareType.UNSAFE_REDIRECT,
        explanation="User-controlled redirects can be used for phishing.",
        remediation="Validate redirect URLs against allowlist of trusted domains.",
    ),

    # ═══════════════════════════════════════════════════════════
    # REGEX DOS (REDOS)
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="REDOS-001",
        name="Dangerous Regex Pattern",
        description="Detects regex patterns vulnerable to ReDoS",
        pattern=r'(?:new\s+RegExp|\/)\s*[^\n]*(?:\([^)]*\+[^)]*\)\+|\([^)]*\*[^)]*\)\*|\([^)]*\*\)\+)',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.REGEX_DOS,
        explanation="Nested quantifiers in regex can cause catastrophic backtracking.",
        remediation="Use regex-safe libraries. Limit input length. Set timeout.",
    ),

    # ═══════════════════════════════════════════════════════════
    # MORE TYPOSQUATTING PATTERNS
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="TYPOSQUAT-002",
        name="Typosquatting - Common Misspellings",
        description="Detects more common typosquatting patterns",
        pattern=r'"(underscroe|chalker|colours|cross-envv|dotenvv|expresss?-|axio[^s]|lodag?sh|momment|babel-[a-z]*-[a-z]*s)"',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.TYPOSQUAT,
        explanation="Package name is likely a typosquat of a popular package.",
        remediation="Verify package name. Remove and install correct package.",
    ),
    MaliciousPattern(
        id="TYPOSQUAT-003",
        name="Typosquatting - Scope Confusion",
        description="Detects packages mimicking scoped packages",
        pattern=r'"(?!@)(?:angular-|react-native-|vue-|next-)[a-z]+-[a-z]+-[a-z]+"',
        pattern_type="regex",
        threat_level=ThreatLevel.MEDIUM,
        malware_type=MalwareType.TYPOSQUAT,
        explanation="Unscoped package mimicking official scoped package naming.",
        remediation="Verify publisher. Use official scoped packages (@angular/, @vue/).",
        false_positive_hints=["Legitimate community packages"],
    ),

    # ═══════════════════════════════════════════════════════════
    # DEPENDENCY CONFUSION
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="DEPCONF-001",
        name="Dependency Confusion Marker",
        description="Detects patterns used in dependency confusion attacks",
        pattern=r'"(?:internal-|private-|corp-|company-)[a-z-]+":\s*"[^"]*"',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.DEPENDENCY_CONFUSION,
        explanation="Package name suggests internal package that may have been hijacked.",
        remediation="Verify package source. Use scoped packages for internal deps.",
        false_positive_hints=["Legitimate private packages with registry config"],
    ),

    # ═══════════════════════════════════════════════════════════
    # MORE CRYPTO MINER PATTERNS
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="MINER-002",
        name="WebAssembly Crypto Mining",
        description="Detects WebAssembly-based crypto miners",
        pattern=r'WebAssembly\.(?:instantiate|compile).*(?:hashrate|nonce|difficulty|cryptonight)',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.CRYPTO_MINER,
        explanation="WebAssembly-based crypto mining using visitor's CPU.",
        remediation="Remove mining code. Check for unauthorized resource usage.",
    ),
    MaliciousPattern(
        id="MINER-003",
        name="Worker Thread Mining",
        description="Detects mining operations in Web Workers",
        pattern=r'new\s+Worker\s*\([^)]*(?:miner|hash|crypto)',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.CRYPTO_MINER,
        explanation="Background mining using Web Workers to avoid detection.",
        remediation="Audit all Web Worker code. Remove unauthorized miners.",
    ),

    # ═══════════════════════════════════════════════════════════
    # ADDITIONAL CVE-SPECIFIC PATTERNS
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="CVE-2024-21488",
        name="network RCE",
        description="Detects network package RCE exploitation",
        pattern=r'require\s*\(\s*[\'"]network[\'"]\s*\)',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.RCE,
        cve_ids=["CVE-2024-21488"],
        explanation="network package contains arbitrary code execution vulnerability.",
        remediation="Remove network package or update to patched version.",
    ),
    MaliciousPattern(
        id="CVE-2024-29041",
        name="Express.js Open Redirect",
        description="Detects Express redirect vulnerability",
        pattern=r'res\.redirect\s*\(\s*[\'"]\/\/|res\.redirect\s*\(\s*req\.',
        pattern_type="regex",
        threat_level=ThreatLevel.MEDIUM,
        malware_type=MalwareType.UNSAFE_REDIRECT,
        cve_ids=["CVE-2024-29041"],
        explanation="Express.js redirect can be exploited for open redirect attacks.",
        remediation="Update Express to 4.19.2+. Validate redirect URLs.",
    ),
    MaliciousPattern(
        id="CVE-2024-28849",
        name="follow-redirects SSRF",
        description="Detects follow-redirects SSRF vulnerability",
        pattern=r'require\s*\(\s*[\'"]follow-redirects[\'"]\s*\)',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.SSRF,
        cve_ids=["CVE-2024-28849"],
        explanation="follow-redirects leaks Authorization header to third parties.",
        remediation="Update follow-redirects to 1.15.6+.",
    ),
    MaliciousPattern(
        id="CVE-2024-24758",
        name="undici SSRF/Header Leak",
        description="Detects undici fetch SSRF vulnerability",
        pattern=r'require\s*\(\s*[\'"]undici[\'"]\s*\).*fetch',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.SSRF,
        cve_ids=["CVE-2024-24758"],
        explanation="undici fetch leaks cookies and auth headers on redirect.",
        remediation="Update undici to 6.6.1+ or 5.28.3+.",
    ),
    MaliciousPattern(
        id="CVE-2024-37890",
        name="ws DoS Vulnerability",
        description="Detects vulnerable ws WebSocket package",
        pattern=r'require\s*\(\s*[\'"]ws[\'"]\s*\).*new\s+WebSocket',
        pattern_type="regex",
        threat_level=ThreatLevel.MEDIUM,
        malware_type=MalwareType.REGEX_DOS,
        cve_ids=["CVE-2024-37890"],
        explanation="ws package vulnerable to DoS via malicious HTTP headers.",
        remediation="Update ws to 8.17.1+, 7.5.10+, or 6.2.3+.",
    ),
    MaliciousPattern(
        id="CVE-2024-4068",
        name="braces ReDoS",
        description="Detects braces package ReDoS vulnerability",
        pattern=r'require\s*\(\s*[\'"]braces[\'"]\s*\)',
        pattern_type="regex",
        threat_level=ThreatLevel.MEDIUM,
        malware_type=MalwareType.REGEX_DOS,
        cve_ids=["CVE-2024-4068"],
        explanation="braces package vulnerable to ReDoS via nested patterns.",
        remediation="Update braces to 3.0.3+.",
    ),

    # ═══════════════════════════════════════════════════════════
    # ENVIRONMENT VARIABLE ABUSE
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="ENV-001",
        name="Process Environment Dump",
        description="Detects dumping entire process.env",
        pattern=r'JSON\.stringify\s*\(\s*process\.env\s*\)|Object\.(?:keys|values|entries)\s*\(\s*process\.env\s*\)',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.DATA_EXFIL,
        explanation="Dumping all environment variables exposes secrets.",
        remediation="Only access specific needed environment variables.",
    ),
    MaliciousPattern(
        id="ENV-002",
        name="CI/CD Token Access",
        description="Detects access to CI/CD environment tokens",
        pattern=r'process\.env\.(?:GITHUB_TOKEN|GITLAB_TOKEN|CI_JOB_TOKEN|CIRCLE_TOKEN|TRAVIS_TOKEN|NPM_TOKEN)',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.CREDENTIAL_THEFT,
        explanation="Accessing CI/CD tokens can enable supply chain attacks.",
        remediation="Audit token usage. Limit token permissions. Use OIDC where possible.",
    ),

    # ═══════════════════════════════════════════════════════════
    # FILE SYSTEM ABUSE
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="FS-001",
        name="Arbitrary File Read",
        description="Detects reading sensitive system files",
        pattern=r'fs\.readFile(?:Sync)?\s*\([^)]*(?:/etc/passwd|/etc/shadow|\.env|\.npmrc|\.git/config)',
        pattern_type="regex",
        threat_level=ThreatLevel.CRITICAL,
        malware_type=MalwareType.CREDENTIAL_THEFT,
        explanation="Reading sensitive system or config files to steal credentials.",
        remediation="Remove file access to sensitive paths. Use allowlists.",
    ),
    MaliciousPattern(
        id="FS-002",
        name="Recursive Directory Deletion",
        description="Detects dangerous recursive file deletion",
        pattern=r'fs\.rm(?:Sync)?\s*\([^)]*\{\s*(?:recursive|force)\s*:\s*true|rimraf\s*\(\s*[\'"]/',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.RCE,
        explanation="Recursive deletion can destroy critical files or entire directories.",
        remediation="Validate paths before deletion. Use path allowlists.",
    ),

    # ═══════════════════════════════════════════════════════════
    # NETWORK ABUSE
    # ═══════════════════════════════════════════════════════════
    MaliciousPattern(
        id="NET-001",
        name="Tor/Proxy Connection",
        description="Detects connections through Tor or proxies",
        pattern=r'socks(?:5|4)?://|\.onion[:/]|tor-request|socksv5',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.DATA_EXFIL,
        explanation="Using Tor/proxies often indicates attempt to hide C2 traffic.",
        remediation="Audit network connections. Remove unauthorized proxy usage.",
    ),
    MaliciousPattern(
        id="NET-002",
        name="DNS Exfiltration",
        description="Detects DNS-based data exfiltration",
        pattern=r'dns\.resolve|\.lookup\s*\([^)]*\+.*\+',
        pattern_type="regex",
        threat_level=ThreatLevel.HIGH,
        malware_type=MalwareType.DATA_EXFIL,
        explanation="DNS queries can be used to exfiltrate data.",
        remediation="Monitor DNS queries. Use DNS filtering.",
    ),
]


# ─────────────────────────────────────────────────────────────────
# MALWARE ANALYZER CLASS
# ─────────────────────────────────────────────────────────────────

class MalwareAnalyzer:
    """
    Deep code analyzer for detecting and remediating malicious npm packages
    """

    # File extensions to scan
    SCAN_EXTENSIONS = {'.js', '.mjs', '.cjs', '.ts', '.tsx', '.jsx', '.json'}

    # Directories to skip
    SKIP_DIRS = {'node_modules', '.git', '.svn', 'dist', 'build', '.next', '__pycache__'}

    def __init__(self, quarantine_dir: str = "/tmp/shellockolm/quarantine"):
        self.patterns = MALICIOUS_PATTERNS
        self.quarantine_dir = Path(quarantine_dir)
        self.quarantine_dir.mkdir(parents=True, exist_ok=True)

    def scan_file(self, file_path: Path) -> List[MalwareMatch]:
        """Scan a single file for malicious patterns"""
        matches = []
        file_path = Path(file_path)

        try:
            content = file_path.read_text(encoding='utf-8', errors='ignore')
            lines = content.split('\n')

            for pattern in self.patterns:
                if pattern.pattern_type == "regex":
                    for i, line in enumerate(lines):
                        try:
                            regex_matches = re.finditer(pattern.pattern, line, re.IGNORECASE)
                            for m in regex_matches:
                                # Get context (3 lines before and after)
                                start = max(0, i - 3)
                                end = min(len(lines), i + 4)

                                match = MalwareMatch.from_pattern(
                                    pattern,
                                    file_path=str(file_path),
                                    line_number=i + 1,
                                    line_content=line,
                                    context_before=lines[start:i],
                                    context_after=lines[i+1:end],
                                    matched_text=m.group(),
                                )
                                matches.append(match)
                        except re.error:
                            pass  # Skip invalid regex patterns

        except Exception as e:
            pass  # Skip files that can't be read

        return matches

    def scan_package_json(self, pkg_path: Path) -> List[MalwareMatch]:
        """Scan package.json for malicious patterns"""
        matches = []
        pkg_path = Path(pkg_path)

        try:
            content = pkg_path.read_text()
            pkg_data = json.loads(content)
            lines = content.split('\n')

            # Check scripts
            scripts = pkg_data.get('scripts', {})
            for script_name, script_cmd in scripts.items():
                for pattern in self.patterns:
                    if pattern.pattern_type == "regex":
                        try:
                            if re.search(pattern.pattern, script_cmd, re.IGNORECASE):
                                # Find line number
                                line_num = 1
                                for i, line in enumerate(lines):
                                    if script_name in line:
                                        line_num = i + 1
                                        break

                                match = MalwareMatch.from_pattern(
                                    pattern,
                                    file_path=str(pkg_path),
                                    line_number=line_num,
                                    line_content=f'"{script_name}": "{script_cmd}"',
                                    context_before=[],
                                    context_after=[],
                                    matched_text=script_cmd,
                                    package_name=pkg_data.get('name'),
                                    package_version=pkg_data.get('version'),
                                )
                                matches.append(match)
                        except re.error:
                            pass

            # Check dependencies for typosquatting
            all_deps = {
                **pkg_data.get('dependencies', {}),
                **pkg_data.get('devDependencies', {}),
            }

            for pattern in self.patterns:
                if pattern.malware_type == MalwareType.TYPOSQUAT:
                    for dep_name in all_deps:
                        try:
                            if re.search(pattern.pattern.replace('"', ''), f'"{dep_name}"', re.IGNORECASE):
                                match = MalwareMatch.from_pattern(
                                    pattern,
                                    file_path=str(pkg_path),
                                    line_number=1,
                                    line_content=f'"{dep_name}": "{all_deps[dep_name]}"',
                                    context_before=[],
                                    context_after=[],
                                    matched_text=dep_name,
                                    package_name=pkg_data.get('name'),
                                )
                                matches.append(match)
                        except re.error:
                            pass

        except Exception as e:
            pass

        return matches

    def scan_directory(self, path: str, recursive: bool = True,
                       max_depth: int = 10, scan_node_modules: bool = False) -> AnalysisReport:
        """
        Scan a directory for malicious code

        Args:
            path: Directory to scan
            recursive: Scan subdirectories
            max_depth: Maximum recursion depth
            scan_node_modules: Whether to scan inside node_modules
        """
        import time
        start_time = time.time()

        scan_id = hashlib.md5(f"{path}{datetime.now().isoformat()}".encode()).hexdigest()[:12]
        target_path = Path(path).resolve()
        all_matches: List[MalwareMatch] = []
        files_scanned = 0
        packages_scanned = 0

        def should_skip(dir_name: str) -> bool:
            if dir_name in self.SKIP_DIRS:
                if dir_name == 'node_modules' and scan_node_modules:
                    return False
                return True
            return False

        def scan_recursive(current_path: Path, depth: int = 0):
            nonlocal files_scanned, packages_scanned

            if depth > max_depth:
                return

            try:
                for item in current_path.iterdir():
                    if item.is_file():
                        # Check package.json
                        if item.name == 'package.json':
                            packages_scanned += 1
                            matches = self.scan_package_json(item)
                            all_matches.extend(matches)

                        # Check JS/TS files
                        elif item.suffix in self.SCAN_EXTENSIONS:
                            files_scanned += 1
                            matches = self.scan_file(item)
                            all_matches.extend(matches)

                    elif item.is_dir() and recursive:
                        if not should_skip(item.name):
                            scan_recursive(item, depth + 1)

            except PermissionError:
                pass

        scan_recursive(target_path)

        duration = time.time() - start_time

        return AnalysisReport(
            scan_id=scan_id,
            scan_time=datetime.now(),
            target_path=str(target_path),
            files_scanned=files_scanned,
            total_files_scanned=files_scanned,
            packages_scanned=packages_scanned,
            total_packages_scanned=packages_scanned,
            matches=all_matches,
            duration=duration,
        )

    def quarantine_file(self, file_path: str, report: AnalysisReport) -> bool:
        """Move a malicious file to quarantine"""
        try:
            src = Path(file_path)
            if not src.exists():
                return False

            # Create quarantine subdirectory for this scan
            quarantine_subdir = self.quarantine_dir / report.scan_id
            quarantine_subdir.mkdir(parents=True, exist_ok=True)

            # Preserve directory structure in quarantine
            relative_path = src.name
            dest = quarantine_subdir / relative_path

            # Create metadata file
            metadata = {
                "original_path": str(src.resolve()),
                "quarantine_time": datetime.now().isoformat(),
                "scan_id": report.scan_id,
                "file_hash": hashlib.sha256(src.read_bytes()).hexdigest(),
            }

            shutil.move(str(src), str(dest))
            (dest.parent / f"{dest.name}.metadata.json").write_text(json.dumps(metadata, indent=2))

            report.quarantined_files.append(str(src))
            return True

        except Exception as e:
            return False

    def remove_package(self, package_name: str, project_path: str, report: AnalysisReport) -> bool:
        """Remove a malicious package from node_modules and package.json"""
        try:
            project = Path(project_path)

            # Remove from node_modules
            node_modules = project / 'node_modules' / package_name
            if node_modules.exists():
                # Quarantine first
                quarantine_subdir = self.quarantine_dir / report.scan_id / 'packages'
                quarantine_subdir.mkdir(parents=True, exist_ok=True)
                shutil.move(str(node_modules), str(quarantine_subdir / package_name))

            # Remove from package.json
            pkg_json_path = project / 'package.json'
            if pkg_json_path.exists():
                pkg_data = json.loads(pkg_json_path.read_text())
                modified = False

                for dep_key in ['dependencies', 'devDependencies', 'optionalDependencies']:
                    if dep_key in pkg_data and package_name in pkg_data[dep_key]:
                        del pkg_data[dep_key][package_name]
                        modified = True

                if modified:
                    pkg_json_path.write_text(json.dumps(pkg_data, indent=2))

            # Remove from package-lock.json
            lock_path = project / 'package-lock.json'
            if lock_path.exists():
                lock_data = json.loads(lock_path.read_text())
                if 'packages' in lock_data:
                    keys_to_remove = [k for k in lock_data['packages'] if package_name in k]
                    for k in keys_to_remove:
                        del lock_data['packages'][k]
                    lock_path.write_text(json.dumps(lock_data, indent=2))

            report.removed_packages.append(package_name)
            return True

        except Exception as e:
            return False

    def clean_malicious_code(self, file_path: str, matches: List[MalwareMatch],
                             report: AnalysisReport) -> bool:
        """
        Surgically remove malicious code from a file while preserving safe code
        Creates backup before modification
        """
        try:
            src = Path(file_path)
            if not src.exists():
                return False

            # Create backup
            backup_dir = self.quarantine_dir / report.scan_id / 'backups'
            backup_dir.mkdir(parents=True, exist_ok=True)
            backup_path = backup_dir / f"{src.name}.backup"
            shutil.copy2(str(src), str(backup_path))

            content = src.read_text()
            lines = content.split('\n')

            # Get unique line numbers to remove (sort descending to avoid index shifting)
            lines_to_comment = sorted(set(m.line_number - 1 for m in matches), reverse=True)

            for line_idx in lines_to_comment:
                if 0 <= line_idx < len(lines):
                    original = lines[line_idx]
                    # Comment out the malicious line with warning
                    lines[line_idx] = f"// [SHELLOCKOLM REMOVED - MALICIOUS] {original}"

            src.write_text('\n'.join(lines))
            report.cleaned_files.append(file_path)
            return True

        except Exception as e:
            return False

    def generate_report(self, report: AnalysisReport, output_path: Optional[str] = None) -> Dict[str, Any]:
        """Generate a detailed analysis report"""
        critical_count = sum(1 for m in report.matches if m.threat_level == ThreatLevel.CRITICAL)
        high_count = sum(1 for m in report.matches if m.threat_level == ThreatLevel.HIGH)
        medium_count = sum(1 for m in report.matches if m.threat_level == ThreatLevel.MEDIUM)

        output = {
            "scan_id": report.scan_id,
            "scan_time": report.scan_time.isoformat(),
            "target_path": report.target_path,
            "files_scanned": report.files_scanned,
            "packages_scanned": report.packages_scanned,
            "duration": report.duration,
            "total_matches": len(report.matches),
            "critical_count": critical_count,
            "high_count": high_count,
            "medium_count": medium_count,
            "summary": {
                "files_scanned": report.files_scanned,
                "packages_scanned": report.packages_scanned,
                "total_findings": len(report.matches),
                "critical": critical_count,
                "high": high_count,
                "medium": medium_count,
                "quarantined_files": len(report.quarantined_files),
                "removed_packages": len(report.removed_packages),
                "cleaned_files": len(report.cleaned_files),
            },
            "matches": [],
            "findings": [],
            "actions_taken": {
                "quarantined": report.quarantined_files,
                "removed_packages": report.removed_packages,
                "cleaned_files": report.cleaned_files,
            },
        }

        for match in report.matches:
            finding = {
                "id": match.pattern_id,
                "pattern_id": match.pattern_id,
                "pattern_name": match.pattern_name,
                "name": match.pattern_name,
                "threat_level": match.threat_level.value,
                "malware_type": match.malware_type.value,
                "cve_ids": match.cve_ids,
                "file_path": match.file_path,
                "file": match.file_path,
                "line_number": match.line_number,
                "line": match.line_number,
                "matched_text": match.matched_text,
                "line_content": match.line_content,
                "context": {
                    "before": match.context_before,
                    "after": match.context_after,
                },
                "explanation": match.explanation,
                "remediation": match.remediation,
            }
            if match.package_name:
                finding["package_name"] = match.package_name
                finding["package_version"] = match.package_version
            output["matches"].append(finding)
            output["findings"].append(finding)

        if output_path:
            Path(output_path).parent.mkdir(parents=True, exist_ok=True)
            Path(output_path).write_text(json.dumps(output, indent=2))

        return output


# ─────────────────────────────────────────────────────────────────
# CONVENIENCE FUNCTIONS
# ─────────────────────────────────────────────────────────────────

def quick_scan(path: str) -> AnalysisReport:
    """Quick scan without node_modules"""
    analyzer = MalwareAnalyzer()
    return analyzer.scan_directory(path, scan_node_modules=False)


def deep_scan(path: str) -> AnalysisReport:
    """Deep scan including node_modules"""
    analyzer = MalwareAnalyzer()
    return analyzer.scan_directory(path, scan_node_modules=True)


def scan_and_clean(path: str, auto_quarantine: bool = True) -> AnalysisReport:
    """Scan and automatically quarantine critical findings"""
    analyzer = MalwareAnalyzer()
    report = analyzer.scan_directory(path, scan_node_modules=True)

    if auto_quarantine:
        # Group matches by file
        files_with_critical = {}
        for match in report.matches:
            if match.pattern.threat_level == ThreatLevel.CRITICAL:
                if match.file_path not in files_with_critical:
                    files_with_critical[match.file_path] = []
                files_with_critical[match.file_path].append(match)

        # Quarantine files with critical findings
        for file_path in files_with_critical:
            analyzer.quarantine_file(file_path, report)

    return report


if __name__ == "__main__":
    # Quick test
    import sys
    if len(sys.argv) > 1:
        path = sys.argv[1]
        analyzer = MalwareAnalyzer()
        report = analyzer.scan_directory(path)
        result = analyzer.generate_report(report)
        print(json.dumps(result, indent=2))
    else:
        print("Usage: python malware_analyzer.py <path>")
